<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Uber Login</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Uber Login</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9d87bd77b6d41bab7f50551c85a2bf20b39688611c7a855928b3cf1b22e7f6df1c73fca4942914d4d48cac544e90c438c7e341fcc5e3098ade42bd6836e5e2b4c70cbba697c267ccbd860533a107f861418dd4a6ab7412ad8194af10f54b38ef98e6c49556b7ac2d1d26accc2e59077b592e6515d2201a7786493f506a99286f09bcd7d967860c0615b57072912e742617075abf1ba960e636fc8a61fd58b6ba1ec1e48f17a9b641f14bfd85e121cd6183217080f46c082c8b96d52e5de67f34d80d1e19b3f1a9d242f39338c2bd32d4b81237152b00440fa071105e21fe1d54516cdc1ebc80b5352ac23b537dc146f782ba4f9c6e3105822a5d94c4a2f7a87629ba46e790276b789c0dfdfbc853683e1a0daf81e81ed10c7b8990e229cc963cfac211878d691e619bfc7672d9924622544aa1df08cb2a18a6054e38cac87fc69adcfc8e52e1a96fc9b60f30e1889d72de20af050328e24c54e67006263c081905a347ec8f75892c45c21cae0cd71d4a309b64f2df7307b39af4008d0f51eb7e11d8ee2da39ae3832379d90a17d05eb9fc8c6daf7e638889158aae3e42d4628846aecc3ff00c1a341710f7b4fecf1e327f51294b94d84300791d03e829ee44b213d194a85eb8213f5136be0a57dc6ef48fe8c62b48fdc5a6db2727163bbbd03bb3b20e4bd569aa2ac57aef07ac1407ed0d342dda59133420e1d8b20c2dd5345693c39de6fe6442a7dd8da6ce4a9b38077816875bd092dc6ad4ebacecd67fb7294f4afb7bafc5ca7eeef91481e8abe50e3637f298625d48b9969a9ce2d7896771029656e0d52bd51eabaf9aa3e222a7d18b5158d9f57beb50f3e3e84b39f9f15c0a2e320bf21628b23da0d251aa83eaa8c32b4ee780fe52fdf05271ec051f77995adb543b1ad993cf6f3e87de47cc58e853fd7120dc98a3a6163e44c61203ab6d679be3a44b5d294a7b584041081179c7feb172322f3cd8432a75f994376fc9bd66913fcf92e0c66301a6a4b7ce0f879ef27ee7540501a3dfccf6c5a4d3525bee6781d7278feebbd18a0fd966df4fcc8269a10dc6aee7cd08c3d971876a36476aa482274d42da3b2cdb0e4fdf9a73de8c4134fd071d39f3f2f385e107a44cf4b2a832922ccb29f4b568851d35c8dd12359a808107bded561f2287343559365ae8530fec6cae3f09d0099c5959532b6c182803e2df9184b22482bd9317eb5e1f725f63356b640af516f50a76cad440ed9f38e98b593e603f39485225bb21fd199db4c00728ba7542a56d19096b93c7717feb9bee8e2564aa5d1fd33bd70db72b33f73389a36dec85c9eeeff3aa8acd0dd7ca9793f8ee95c63ddc2751683c91e006fc3dd749de13f58a34abd1050861cc064fe0fdc696677856c77fbcd7ff31f5dcd742d7cf4a081be45f81d02aea20f6c27a9b345273078834173fba9d4079d317115e9ff33d869ca110996da63a38204b714a269ed26aca44d3ef4937c753673516bc2a30da39dd44cd90dee9d71a1d2e051b3a977e5a8d9307f219a3be267cfb90ae1b701c055321c6ba328bcd12bc027d8607a803b4fcb130d301d7a1fabd889f736c9f46d6e62112f156cb17119357becf1bf4c37816d9ffd7d1097c69ffe4ad0c2aa31c6caa2e69d910b0b0ba977c151bb1a972aa7e43cf810274e93b5d0dbbca993251b3f6d17b69d7ac27aa492ce4d29d4f17940b94a9e816822d5d60767a9c56f6dc3872214dc9e53f30e7931407bc8a8c66604fd6c8fa25c8304e627e9841bae48b5aa4e1c45343555b1230f760bbd68b840f2c864d554b6b0ca236681d13d9505a2c558fd13ec9d34ff2b246f46a33c78e83077d8f5296a810baaa66c09d738134981db63769c1c32e7c651f532d10788d7ea004fa383d0ed80c544f01d138d512be4dbc08de31b859db54c0f941fadf562baccb48cf71cd9a5d4a7a7ac55e59ea4e48e9274b92617cee57fb4484087c343d138c9f8e2978a39abf802c49c04474ec65b5e4a364bb046b2622ceb530efc519b6b4f6a71de56ff9bf42e914641c6c507d16d3792e0ac090873332c9a0ec75971358b8376c99169ce3f21c7b6401627b4e8acecf49312bf3fef145a39fbbc7f9880e7b908cbd3cea819b493277549d5c76ccef3a26d6e2d849981074f485a239a08ec38d30073542a5ccf7eaf846f15698f48eb52d6a432ab42285667c524da6d5efdfda417629e405e4b44d8e27979e550ac2321f72697a6c90042abfdb984fc2adfdeeb8a37a23acf7808bc5bc336112c64e6d0678743be904f92a6f24d8b9dd8f40910e14624008b023fb3bdadc50e64d00424d8a0a6cca3466be1deef0fbe3009253bc5cbde1cffb5718b50794d81bc68c4c14e97178c67049371372e37a4fa206eaa2aeada1901701960f87662f2a8a6889fd6544e23aa2b88a9426de1a784469a92d101af1fda0cd7d45b7f545f26e00820b8208bea3f38d09276852d8abb2ed9620b8cc6f078d2acdb2b2e92d66f562c5355e83fcac4b2820bb70d27ca998472e21527c352b607f786bc5e59e4c852729061e19a1942e1b975f850cba05ec1964015dbb38050e1a8dfc6ddbe6f0e66577145e9609a9559f6e3eba6ff7657d2267f7d5aeaca0ecf23f2cb03d928acf11a13a46a82530f219f6575c3b3404e35a67a4418493639a2595c1ac45144f1924cd6710294e956149b5edaa864e29b6fdba5c95ecdb451b535be685ce6ea39c49194c05e9357c6c30e528f28d039b946418872bbb641e2e21ed49fb4f331d8106e170da4639ed9fd47fa5b8eb1501fc4770eeaf0ed908faafd5b3b302d5a0b7819c6882349f54539fc30da33ebbd6fac4b56cff15307d06192c921cdb6d42f472478c9ff66d409aeed876833752e95cf1388389af10a673d56fefcbcc5a1b18b1a08a02a04d9e86c1da89f190ede4f7ae498c4fc9a723b1e8d9c51da57632a2d72d20789004a3d84a3c3ab0a3b6a8f905eaaa69d2da0a8634dc6fa2ae7fa68f7f67b373ade20d9cda758ec2f13398a60b7beb76ad495660414cd6e9387ea00746a4cbcdac67f3de4cd5220e907969063044ebf208da63b36fc13b63518b62745e428262e51bd89255fdad3337cb9f662fe0cde3eda47b59397c98375d6e4fa99c25e8e4627139fb56149215b0ef38e5e3329174e7ebd4f2a035e5a80fa9022d1129d19be8ba8b2ffd140fa011a6e673037a942aae43e6455478f1eb3086ee17e17275e019be60eda92ef82099561eb025a75ec6069259ae9e180ad2c26ccb843b8b32dfd6c5f5309c289d4cc3c7a4a74cf6b132d4003b91c0c4e4795ea0ba87c5d67bb9777a90d13568259813a93e88002366545ffed3fb24b03c7de0777e2d3d343606fa54aab25f789b4a9a227d6cb49a056a6ef2be2a3cb1bc2ad7d06d4c87e9fb5af48f86bcadb09d3281d3d75d33c6d01e4235036d36df4e2038b5277d7ae9bfcdc3748e2cb8fc11033d64f6a4d274e61546f0a3b937a3d6f18bd066fe6badac561d0918b56f078301ce6084b812d01b5ba641878e963780852ccdcb1da383d23730de82c1ac40800b590aab40465f288546f48f50fc3a950f1a88b86759f6075d9241c5108fad9b88e67e63780433f531ddb7366a9a0fc405b0e0aab59a000502efd5ef9d16bd15bc48ae5571eb499956d1ce47cca52299074be5339676609e251f7c55fd4c6bb6659d5643413c8ae8e59a449bdb7135f45e8617cac89aa2fb971dd748676d3cb9e00d20953a5b4c80186f39dfda2fc4859cefb81b389db6c3495cb8f54dcfa7568d930fde24cdfe24b97c7cbca5805f766bcb6d11ae79ed0248bf64e5235ce37225f8287c174a53651ae3abfd4f0d59ed3df9b45a6d20d228b5ece905fcefbe7c92394482ef1dfceefb9affd7782d4aaaa1851583787d83ce3ce4a0d6c2ff09d96d0e6b3820e9bd09c2f68c35659ed90926f90eb1b5f680c005daa4e739ff83cbd033ecf901030c94bff5a2010f3ef7ce46c20049e70361d8bbe8557b5c40cdfaa57c9efc69d510bbf5e241680372a61ffa7d68a081fa15aa959631dd5aa3e618c5171cdf3ab515fe833db3acab31695023320b9cba325bd28a9686b7d347b6a40525faf08e6771d14432b80e276dcea3f14416b77eff6cd3252aac5acc01c268d53e332bfc6922ce7233087c49df4c283388ddc1e4ab69a8c1a86c1e7f3559cd0b7a1493978ed91b311dcefc4e52e4d66b325bfecc5df6c39747da912fe98a75fce0e4231171dc9c04475f680e29f24449b12a3a9d6dedf9e70eb0313fc0b4be309a2980b77f71884ddfa984fbc0bd1fc7b994fefb8440125995ff8fbbc741fb1287019d4a191cb5992eea2bc37b1275fe34297ac4370d739dffd5b80a530db27e7402c7b47408790b88055017a2b766d8c64ede872af6c3b8692e9ef54cb37f84d6e5546c093913d6ff2decbfea623731469cc1536224abc31056eca27b91eea347da321e2ecaac4374c5703595dfb80c21a73c877a070e27c5d281af8a7983e8074b5bc43565ba17aa70de553f304e3d5804e48813ff1ce4ac04555eb5ec080c72564fcdf9fb7c5f5c3a43fbf72b09e2b6cd62747c21e44d2c0b088a363361baf4dca6045913194f33a0817075cf21dbb21adf48cede6555f0343f105f8aa49c432fb079517f2cdb330941bd8f57fa3838233c1b1563e76a65c13a3107811f19b0374d704d5ed65e8724f96f78cff8ace26daa5b0611d61354576001f42c574fb84db345522e966a04883749ba78313efa28c6ca166798072da0e56dadce3c1b4b1630a0c37757f85ecdde68460be4cdab1a0d93e9605285982a7ce2c14101c8f7515f19aa0615e1e516b2cc0a6c92cb2e7b640b751fcfc6c6db2814f1739ce0dc7650fa8e97ea3925c34be9b57dadf8ef9cdb1dc2919222e7806c2ac87af5ec64a37501e91b9380ca164f6b5ea348295d6707127973f82e00759aa209818da016c31d551989164403560d67602ea76d42dc43703d6da04f5ddad14bc141ea20c90f793b31ad5c18eb16767b61c78721ad99b861685c1987a36e2bf06674c99d9ff8573ff25c5d94ae6639b5be3ea3496f8f4e61a43249039de0ab8c3dc04e8a70f5d5d1d8e45c2c294cf1937927833d32a0854d5b3baea26c143b6de16eca040ece2aafa66478ae8230e5013cf48bca4113d3140a4fbd269c82565861510d30ed21264bbbf023007465093654eff381f642a07f9dc2e2cbf3c39e36ffde3ebe5db61695e0c2ecaeb50f50e83cd7e48f41d1c4345b32167745c1ceb2dc24622bda2dad7dfb9304a9f1fc56fadc80bd55d071c86ba7fb12e50af89f785682b7a2b19da369867d0b56d8d8d6e98afb35e47a25a0788eab790dfbe10eb7a468fcb1c302bcecc7de9645e435f9951aaed39b14b264324281b6f9199a5447c71390d9e96df675ab33efb05f75c26b45ba163728f137f627aee498a13d8b7fd9af13b4bc68fc966f37c51b858eee5d9f7c0edfeea930091b0b1c3526ef3ae5c5fe6c8976e917aae94a933c80a21fcdc5df5d98e1335e22f776bdbb22e978cfaff03d124af6f23957c23cf9f87e6a337ab092375d17da8abca83cf3b8f4f06cbff87d60d84225a39203788a83906d6c10d7378bf5cf516ebcecbc24dbd8bb8a5fd8ba46898dbe528a77977a81261b9f255efe13689cb09471e2a94b20280549be392df9dbc7b5bfecb19672e51e166c5a828ab132621a14fed66d83682ae4dad26fa8c1de9de9726254ec57e97be7c41b2e937012f2200752b994703295520db7f533d66e91b25ab7c9204d5aacc1780fe7a9209eaab33f9b0e24b60be4b4cb8c0aba04282bf767a82cfa9f7b9a783fcd0e1df8c6c70a112d6c24890780b6a76db5bad0a7cd33cd25a82ba630c5a56da57c9b0f73ca8adc212af50819a5407054d288f8565f68990b1fa6f1325a5c36fbd230765aa1b17bab0aeaeaac30a9c4a80680c625af7d1c1fd5cb270d11b1261caa3d11cd399fb2eacadaf82bbf95d1d042a2f77c9793364efed0c51287e739498c77e543366aca88cabb0cf29da6bdd5473d682c98c1bb0a22b6b51caf327a13dad0a418d079458746cfaa85d819a294c5601fe7d9e528566f6c4eb1058f06ec2cecf49310bd4bcb7de6751f3c1014784558b633070524138d793a1749244526e773ed8bc811d374fe904fe5ce1dcf0e64465da41d03570294c7799da4f717b755bec1b39ebe98f09175b64ed6f077beec19d53c6b39ee1521a596587dd150c6125eb3c06da0d21b4ca22100f0003aec04be1a2c90fb63f7d435a40969561d79f0bc996f0090efbdd8aafc1f1808286073895769e08d450e7aa1c1c2bfd68a94ab7b908ed3fca514ac87ffc53dcb48a7b4003df22cc7bc66e3c7fbfb3563e59de0ba6701306f45e7851d340bcd2576cabbdc8621d35def832f2672b88b33ac7c719c12f41a27af3a575ca339c61b068cb398d3cffa94e933f23a90eb7b3343cf2e4f5f01cff66af92dc4f230cead357ef5cb3d9fba52e39374b997969c1c9470849aa30b9e645eed4a6bb99c1194480c95e2d99140eca2d88212cd1c8e89a9cebce149a8b036a3dda6bb7cd641a480df5eadbab0b9d6c8919232c4198ee06d4279ddd5fa70e80d5ea311a41da0e68a159ea98ea7c76e5b60fae8e92e7f71302632b736dde37a748bbba5a5480885fbff64e84515a2dee5ee78e8c1d2539a0761897350f8e0670a7789dcfcf5a18304ec804bcf9fee7f6e20bf37f28193c8f1cdfc2fcd2c9fc7275f25b840aa030736573c34694b55b346e5abe08fc3b8d79a854c90fec422939488ce08e027940a82d44101c92138a0ea58af77bac0c1ebe91f5767f3b345fed791d91bc3ce24005d3e6d430cbff9e851df4b96c130e6957677e476df1a4c30b824ecb03b4c4a1d1cc0218a600797d699831251e3b685c368131eb2f0f576b6be099649598707c351985ca2d25bffb7b928c4cf72c5d6197561e044f54017e39e025c6bb15d09cd3c86b187fe58aac1e269533a72d587b700d4f459d4007973840f32be3b7b1122714155eb75496be6169060e8c00caebfa090ee926c584c68f728a6b8dae323bea34740fa9c12d4fa63d98b584a5acfd0dea017dad704c658f8fcd72cbf266e2b4e2b872e02bd3f86b11aa9167488588874fab0f226c1a60b9467c630c7b1b3f1289bc357d156d7cd9e28f13abe8bee1746b391d704078922f497571a361c9765e51277621f07a14c26d2105a41ff86618ee8e6f610c7ac5c321769ad9df355f415a49c9e446d5c04a3cf48594600055a7cad595c9383e7802e660092529448b00b8b5503f9af3e652f3da043d56015a65b67e2390e1e68f8cd764b2a10d585e6a0a4aefa8e38c5ec0fad7d88272f975618a693a0901862efba48d6f5b6c8aec81830ca0ff58da4fada4ee99e51fe7467809e72000dd774f956ddf4a3f76b18779944ccb6bb841cc05970dc2e8306d0b7a74aeb6c63bed7e088a66f6057d0a3d9c830c3398d934f0d419cf89cb8abd5b006b63a86a4160bf3535b3f28c5d48af092dd88f72623cec89892dc5a1dcdeac47b3e80d687c6afcb365e158201c67ee477c21f94e4cf3cfbe4336c7e98a1a1c992f4f4db6ee6497af66d7bb2d6594e4c7b9ff892644d02be6f18fd2221d4dfdd6e3c33e4cf6d9bde9d24a0929aaade2938c68709d52983c8e904d85a4e67cd8e5e8dc7cc07d5fbd0049a6fe4e46e73b2de6795798776b1ea12a5099e0884ce456a546a9cc95d2a7b5a36ac1d6d552f99107ddf738e79424e3c5971765234e84ba947446aa0f66cf41a8e452f6468daf3877c330f951c397da290c2d142aa4bd74a0aac1822d59acc83eed89cd6678c28140d83d6ad3f1cda4e5ba5737609d4014420fe22cd66219b227429c593772c7fb528ce0125dade97f6e13285ea64696aff57cc4e696e453827aa1e01e15946044eb58e49c72d01d13a34804d4b6b10ccbfcf25d047c8e9ecda0437a5238e457a0365a64e390d2aed496b7db8bc1c7f4ebb13c09c8184451c12bdfb012f034104b515cc65712f72a556ca1ccccbae1aedde3f46d8b7f027bcb21cd4c2bb1b2d73a277a250e4873304c5cb7f5b66c59d816d59a5afe4bbe9e2872c100102fdf3d3cd2bb53cc38ba6feed152a475f822b1ca961bbcad32bb14fbcd8a2b61413281b1157b9acd3d42fb87a422d87f6677e3a3a2963df530d40b56f55de19cb0e0382ed6c453e35ecc0c3412c2b6b5414654f2cf4a75bdc19e9e1e0fb9f6e5d647d866130516047c231dc8ce64d555cca7542f6369024f865bfaf53bc77247e616c4b7e38e815209d92175658bdafedc9f6d5f2d9290fe621f13363ec7ddafb4e545d0f6d168ffb4864db075aa2e70a39c871998abb24272df531abf81f07b61418d2a19e4f1b1b48579d01415514bf7ee1f907ddba5622ec5688eadca3b19b57456ae115c8735f9f7135294774695fc466cebba8deca847be6c0ebbe195c5c9dfc1e233a54701231c4bf3841895b9dfe134d7bb8f3875251ac91905798c4d72685bb3fc14f9c0e27c13ce34d9c05e37f960abf5a3b242c1c443cf9dff55b496e0b13fa3939e2a8b673ed299985c0b1f7bb07245591609d6d4bb6102c1e91499d4c85a69de9df56205f0431968309485383d9fa982317b4852273405d696dfdd4808c0099fb4a62c9ed450e79c8e5dfeb35eaee7959c3c19b689d0a20390098c8a104904fae3758f5f38ca97fbe08942bdb029fe1c2eaaf5076d0883359ce7e527a208e4fb8490ea78acfd775535639562af84f5cb7023a1c8476923d44e1ad6dad24fb714eb03583a02f6d5453014e2e0a3ae22155cac2768253dfa94ad4291f5495d4273c3083dd4f31e719968ee1ebcd2e17fe20a147e23ac3234e68edee203f4781dfbab0edc234090e5ae57c9b0e10fa9ad058137a7bee80ac0d8148c66bc0bf6ec0430e587a8941ab116547b51fa776070895cc6783708405b455ece71e53d8d85745ef626f8fa1ac2d034650b2231e698a7e21887b55cfbebb448b95e3af3ce3f67f0aabd333b4b639029f2a07a2bc4dac42591b007975fd83f12e8db62281e9702938f8afde5a05deee40a1faa93b471cb2d75c07aa165bcdc9b4ce6df6608b41868df2c01fb3334aa237504cfb7e06d5c291ad5aad658254064bbd7f63abb54133fa0f992243e95ebdaf46bfdb0282ceedbd7b4b7b2cdebf8689aba28ae032befc1e0704c6eea8bb44ea7214dfcb4f1fc1dda14cd18266d2e5fdb8a85df0f14ce13f33d39b05f03bdf346af78283ad1e945f87cc4bf8b862b9fe0f9f66ee3f274f58458f3f0e111ed4626dabf9cca4adf95f4c1beb98094239880874242bd67be9df92e549d2f98ee74a4cd8000d971654120f00d6060a9f2044b02a99e4c304cb86d4f551563497d0f54c1a3053dc87f3ddf35b5f9cd2cd549a4ecd518f6afdf85eb146f33dcb702ad870cc2601d33be7c9c45bcd84863a297634f0d0b8b1690bcc307a3131c48b91da6ed252049a3e85d97bf0a013daf1a7a1eecc8241a187a38c0affa8535710ae561256d9f32793e71f07a718aaaefcdcf929719c10e1a4d3ef63266b15dc1cb8fead31c17840f8f19d3a79c877a6cf5894d383bdd3ba691b93756f37b5c34b311a36e23920825692bfae73cd72a05cbee7f339b02a01e5bd3784110fbd5d5bbfc2b34f295e7bf9798d4a0c7ba39930253741eec1edb8db4ecf681b6b233a25ee4e3fb1cd21b0addde3e72ac8763790c5633f99e3c5b3017610e794f8ff745feea0b0717ed257e8c07525751b12baa768d557cec8976165ac42a0da8c6357fcee6690ffdbcd49e19c7060e8f3f33f3551020b1e06c94f1f4511668b3045989e0596795e1a987256c9f1de02d08e81acdc11efb2d8b37be5ca6f21f918115d91c87d5858a832fd20abc04e2698c62fb1d790533c217cd373a39afae9be711ff5c2728bad79c12663e7b7a3b21288ffcf74104321333cb9fa4ffab9513e2d71d2ba710093075bc46afd9d3337f535df8b696e346eadc8fa813465754ff21e6d491038f100d9c6fd2c1e89c3478dad1ef11164b567c621aa13c585120a0d2ac6cbd5857b087cea488d6302fc8038031df48ed13599b102a78414bf2f210aac3036a83f17d32e94d8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"060a9df72809f7d398776ec14c2e941b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
